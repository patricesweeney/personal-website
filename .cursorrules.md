# Indie Hacker Vertical Slice Architecture Rules

You are an expert Next.js developer focusing on maintainable, scalable "Vertical Slice" architecture. Follow these rules for every code change.

## 1. Directory Structure
- **app/**: Routing only. Pages must be "Waiters"—minimal logic, importing "Views" from features.
- **features/**: The heart of the app. Grouped by domain (e.g., `features/auth`, `features/projects`).
- **components/ui/**: Atomic, shared UI components (Shadcn). No business logic allowed here.
- **lib/**: Shared infrastructure (DB clients, global utils like `cn`).

## 2. The "Vertical Slice" Rule
- When adding a new feature (e.g., "Newsletter"), create `features/newsletter/`.
- Inside a feature folder, use:
    - `components/`: Feature-specific UI.
    - `actions.ts`: Server actions for data mutation.
    - `types.ts`: Feature-specific TypeScript interfaces.
    - `utils.ts`: Helper functions used ONLY by this feature.

## 3. Dependency Rules
- Features CAN import from `components/ui` and `lib`.
- Features SHOULD NOT import from other features (keep them isolated).
- `components/ui` MUST NOT import from `features` or `app`.

## 4. Coding Standards
- Use **Server Components** by default. Only use `"use client"` when interactivity (state, effects, handlers) is required.
- Use **Server Actions** for form submissions and data mutations.
- Use the `cn()` utility for all Tailwind class merging.
- Use absolute imports starting with `@/` (e.g., `@/features/home/components/Hero`).

## 5. Deployment & Speed
- Optimize images using `next/image`.
- Favor simple, readable code over complex abstractions.
- Ensure every page has a Metadata object for SEO.

## 6. Indie Hacker "Bias to Action"
- If a task is small, implement it immediately without over-abstracting.
- Prefer Tailwind utility classes over custom CSS files.
- Use Lucide-React for icons by default.
- Always include a simple 'loading.tsx' for new routes to ensure a good user experience.

## 7. Supabase Defaults (Indie Hacker Vertical Slice Addendum)

### 7.1 Client boundaries
- `lib/supabase/server.ts`: `@supabase/ssr` + `cookies()` only. Server-only imports.
- `lib/supabase/browser.ts`: browser client only. Client-only imports.
- Never share a single “supabase.ts” across server+client.
- Default reads in Server Components via server client.
- Browser client only for realtime, uploads, UI session state.

### 7.2 Session correctness
- Require `middleware.ts` using `@supabase/ssr` to refresh auth cookies.
- Server auth gate uses `supabase.auth.getUser()`.

### 7.3 Key hygiene
- `SUPABASE_SERVICE_ROLE_KEY`: server-only (Modal, verified webhooks, admin maintenance).
- `SUPABASE_SERVICE_ROLE_KEY` must not be used for user-facing reads.
- Default server reads use the cookie-backed server client so RLS stays active.
- `NEXT_PUBLIC_SUPABASE_*`: public by design.
- If bypassing RLS would be required, it must be a server action.

### 7.4 RLS-first contract
- Every new table: `ENABLE ROW LEVEL SECURITY` immediately.
- No feature ships without policies.
- Default multi-tenant: every row has `org_id`; RLS checks membership via `org_memberships` + `auth.uid()`.
- Never trust client-provided `user_id`, `org_id`, `path`; derive from server auth + DB.

### 7.5 Access Control Patterns (80/20)
Three patterns cover 95% of cases. Pick one per table:

**Pattern 1: Owner-only (most common)**
```sql
-- Column: user_id UUID NOT NULL DEFAULT auth.uid()
-- Policy: USING (auth.uid() = user_id)
-- Index: CREATE INDEX idx_<table>_user_id ON <table>(user_id);
```

**Pattern 2: Org/team membership**
```sql
-- Column: org_id UUID NOT NULL
-- Helper: CREATE FUNCTION is_org_member(org_id UUID) RETURNS BOOLEAN
-- Policy: USING (is_org_member(org_id))
-- Indexes: org_id, org_memberships(org_id, user_id), org_memberships(user_id)
```

**Pattern 3: Public read, owner write**
```sql
-- SELECT: USING (published = true OR auth.uid() = author_id)
-- INSERT/UPDATE/DELETE: USING (auth.uid() = author_id)
```

**Storage follows the same patterns:**
- User files: path starts with `auth.uid()::text` (e.g., `{user_id}/filename.csv`)
- Org files: path starts with `org_id` + membership check
- Demo/temp: open bucket with cleanup job

**Rules:**
- Always index columns used in RLS predicates (user_id, org_id).
- Use `SECURITY DEFINER` functions for complex membership checks.
- `DEFAULT auth.uid()` on user_id columns prevents client spoofing.
- Test policies: `SET LOCAL role = 'authenticated'; SET LOCAL request.jwt.claims = '{"sub": "user-uuid"}';`

### 7.6 Migrations + types
- All schema changes via migrations committed to git.
- Generate and commit DB types: `lib/supabase/database.types.ts`.
- Feature `types.ts` may wrap DB types, not replace them.

### 7.7 Vertical Slice data rules
- Reads: `features/<x>/utils.ts` query helpers (pure, no mutations).
- Writes: only `features/<x>/actions.ts` (server actions).
- Prefer DB-level correctness: constraints, unique indexes, triggers, RPC for atomic multi-step ops.

### 7.8 Next.js caching with auth
- Any code path using `cookies()` / `supabase.auth.getUser()` is dynamic.
- Authed routes must enforce dynamic rendering (`dynamic = "force-dynamic"` or no-store reads).
- Never statically cache per-user pages.

### 7.9 Storage defaults (CSV + compute friendly)
- Buckets private by default.
- Object paths namespaced by `auth.uid()` (and `org_id` if multi-tenant).
- Large files: upload to Storage, pass references. Never proxy bytes through Vercel.
- Signed download URLs are server-generated, short TTL, compute-only (Modal).
- Compute writes results to Postgres/Storage; job state is explicit.

### 7.10 Performance + simplicity
- Always `select` explicit columns (no `*`).
- Index every FK used in RLS checks (`user_id`, `org_id`, membership tables).
- Index every column used in RLS predicates and membership joins.
- Job workflows idempotent: results keyed by `job_id`, use `upsert`.
- Start with JSONB results; normalize only when queries demand it.