# Indie Hacker Vertical Slice Architecture

## TL;DR — Quick Decision Guide

| Question | Answer |
|----------|--------|
| Where does new feature code go? | `features/<domain>/` |
| Where do pages go? | `app/` — but pages are thin "waiters" that import from features |
| Server or Client Component? | Server by default. Client only for state/effects/handlers |
| How to mutate data? | Server Actions in `features/<x>/actions.ts` |
| How to read data? | Query helpers in `features/<x>/utils.ts` |
| Supabase client to use? | Server: `lib/supabase/server.ts`. Browser: `lib/supabase/browser.ts` |
| Heavy compute? | Trigger Modal from server action |

---

## 1. Directory Structure

```
app/                    # Routing only. Pages are "waiters" — import Views from features
features/               # Domain logic. One folder per feature (auth, projects, analysis)
  └── <feature>/
      ├── components/   # Feature-specific UI
      ├── actions.ts    # Server actions (mutations)
      ├── utils.ts      # Query helpers (reads)
      └── types.ts      # Feature-specific types
components/ui/          # Shared atomic UI (Shadcn). NO business logic
lib/                    # Infrastructure (Supabase clients, utils like cn())
modal_app/              # Python compute functions (Modal)
```

---

## 2. Dependency Rules

**DO:**
- Features import from `components/ui` and `lib`
- Features export via barrel `index.ts`

**DON'T:**
- Features import from other features
- `components/ui` imports from `features` or `app`
- Circular dependencies anywhere

---

## 3. React + Next.js Patterns

**Server Components (default):**
- No directive needed
- Can `await` data directly
- Use for: pages, layouts, data display

**Client Components (`"use client"`):**
- Required for: useState, useEffect, onClick, onChange
- Keep them small — leaf nodes of the component tree

**Server Actions (`"use server"`):**
- All data mutations
- Called from forms or client components
- Location: `features/<x>/actions.ts`

**DO:**
```tsx
// app/projects/page.tsx — thin waiter
import { ProjectsView } from "@/features/projects";
export default function ProjectsPage() {
  return <ProjectsView />;
}
```

**DON'T:**
```tsx
// ❌ Logic in page file
export default function ProjectsPage() {
  const projects = await getProjects(); // NO — move to feature
  return <div>{projects.map(...)}</div>;
}
```

---

## 4. Coding Standards

- Absolute imports: `@/features/...`, `@/lib/...`, `@/components/...`
- Tailwind via `cn()` utility for class merging
- Icons: Lucide-React
- Images: `next/image`
- Every page: export `metadata` object for SEO
- Every route group: include `loading.tsx`

---

## 5. Supabase

### Client Boundaries

| File | Use Case | Auth |
|------|----------|------|
| `lib/supabase/server.ts` | Server Components, Server Actions | Cookie-backed, RLS active |
| `lib/supabase/browser.ts` | Realtime, uploads, UI session | Cookie-backed, RLS active |
| Service role (env only) | Modal, webhooks, admin scripts | Bypasses RLS |

**DON'T:** Share a single client across server+browser. Never use service role for user-facing reads.

### Auth Flow

1. `middleware.ts` refreshes session on every request (`@supabase/ssr`)
2. Server actions gate with `supabase.auth.getUser()`
3. Never trust client-provided `user_id` — derive from `auth.uid()`

### RLS Patterns (Pick One Per Table)

**Pattern 1: Owner-only**
```sql
ALTER TABLE <table> ENABLE ROW LEVEL SECURITY;
ALTER TABLE <table> ADD COLUMN user_id UUID NOT NULL DEFAULT auth.uid();
CREATE POLICY "owner_access" ON <table> USING (auth.uid() = user_id);
CREATE INDEX idx_<table>_user_id ON <table>(user_id);
```

**Pattern 2: Org/team membership**
```sql
ALTER TABLE <table> ADD COLUMN org_id UUID NOT NULL;
CREATE POLICY "org_access" ON <table> USING (is_org_member(org_id));
-- Requires is_org_member() function + org_memberships table
```

**Pattern 3: Public read, owner write**
```sql
CREATE POLICY "public_read" ON <table> FOR SELECT USING (published = true OR auth.uid() = author_id);
CREATE POLICY "owner_write" ON <table> FOR INSERT, UPDATE, DELETE USING (auth.uid() = author_id);
```

**Storage paths:** `{user_id}/...` or `{org_id}/...` — never trust client-provided paths.

### Data Access Rules

- Reads: `features/<x>/utils.ts` — pure query helpers
- Writes: `features/<x>/actions.ts` — server actions only
- Always `select('col1, col2')` — never `select('*')`
- All schema changes via committed migrations
- Generate types: `lib/supabase/database.types.ts`

### Caching

- Any path using `cookies()` or `getUser()` is dynamic
- Authed routes: `export const dynamic = "force-dynamic"`
- Never statically cache per-user data

---

## 6. Modal Compute

### When to Use Modal

- CPU/GPU-intensive processing (ML, stats, data transforms)
- Jobs > 10 seconds (Vercel timeout)
- Python-only dependencies

### Architecture

```
Next.js Server Action → Modal webhook → Modal processes → Writes to Supabase
```

Job state lives in Postgres (`jobs` table). Modal is stateless compute.

### Project Structure

```
modal_app/
├── app.py              # Modal App + shared config
├── jobs/               # One file per job type
│   ├── poisson.py
│   ├── survival.py
│   └── nrr.py
└── lib/
    └── supabase.py     # Shared Supabase client
```

### File Structure

Single-file for small projects (< 500 lines):
```
modal_app/
└── app.py    # App + image + db helpers + jobs + endpoint
```

Multi-file when it grows:
```
modal_app/
├── app.py           # App + image config only
├── db.py            # Supabase client, update_progress, fail_job
├── jobs/
│   ├── __init__.py  # Exports run_analysis dispatcher
│   ├── poisson.py   # One file per job type
│   └── survival.py
└── endpoints.py     # Web endpoints
```

### Code Patterns

```python
# Always catch errors and write to job record
try:
    result = process(...)
    supabase.table("jobs").update({"status": "done", "result": result}).eq("id", job_id).execute()
except Exception as e:
    supabase.table("jobs").update({"status": "error", "error_message": str(e)}).eq("id", job_id).execute()
    return {"status": "error"}  # Don't re-raise — client reads error from DB
```

### Rules

| Rule | Reason |
|------|--------|
| `.spawn()` not `.remote()` | Async fire-and-forget; don't block webhook |
| Pin all dependency versions | Reproducible builds across deploys |
| Catch exceptions → write to DB | Client polls job status, sees error message |
| Never re-raise after writing error | Avoids duplicate error handling |
| Secrets via `modal secret create` | Never hardcode in code |
| Include `fastapi` in image | Required for `@modal.fastapi_endpoint` |

### Commands

```bash
modal serve modal_app/app.py    # Dev with hot reload
modal deploy modal_app/app.py   # Production deploy
```

---

## 7. Bias to Action

- Small task? Implement immediately, don't over-abstract
- One-time operation? Inline it, don't create a util
- Uncertainty? Ship it, iterate later
- Prefer Tailwind utilities over custom CSS
- Prefer simple code over clever code
