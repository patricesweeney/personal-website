# Indie Hacker Vertical Slice Architecture Rules

You are an expert Next.js developer focusing on maintainable, scalable "Vertical Slice" architecture. Follow these rules for every code change.

## 1. Directory Structure
- **app/**: Routing only. Pages must be "Waiters"—minimal logic, importing "Views" from features.
- **features/**: The heart of the app. Grouped by domain (e.g., `features/auth`, `features/projects`).
- **components/ui/**: Atomic, shared UI components (Shadcn). No business logic allowed here.
- **lib/**: Shared infrastructure (DB clients, global utils like `cn`).

## 2. The "Vertical Slice" Rule
- When adding a new feature (e.g., "Newsletter"), create `features/newsletter/`.
- Inside a feature folder, use:
    - `components/`: Feature-specific UI.
    - `actions.ts`: Server actions for data mutation.
    - `types.ts`: Feature-specific TypeScript interfaces.
    - `utils.ts`: Helper functions used ONLY by this feature.

## 3. Dependency Rules
- Features CAN import from `components/ui` and `lib`.
- Features SHOULD NOT import from other features (keep them isolated).
- `components/ui` MUST NOT import from `features` or `app`.

## 4. Coding Standards
- Use **Server Components** by default. Only use `"use client"` when interactivity (state, effects, handlers) is required.
- Use **Server Actions** for form submissions and data mutations.
- Use the `cn()` utility for all Tailwind class merging.
- Use absolute imports starting with `@/` (e.g., `@/features/home/components/Hero`).

## 5. Deployment & Speed
- Optimize images using `next/image`.
- Favor simple, readable code over complex abstractions.
- Ensure every page has a Metadata object for SEO.

## 6. Indie Hacker "Bias to Action"
- If a task is small, implement it immediately without over-abstracting.
- Prefer Tailwind utility classes over custom CSS files.
- Use Lucide-React for icons by default.
- Always include a simple 'loading.tsx' for new routes to ensure a good user experience.

## 7. Supabase Defaults (Indie Hacker Vertical Slice Addendum)

### 7.1 Client boundaries
- `lib/supabase/server.ts`: `@supabase/ssr` + `cookies()` only. Server-only imports.
- `lib/supabase/browser.ts`: browser client only. Client-only imports.
- Never share a single “supabase.ts” across server+client.
- Default reads in Server Components via server client. Use browser client only for realtime, uploads, UI session state.

### 7.2 Key hygiene
- `SUPABASE_SERVICE_ROLE_KEY`: server-only (server actions, route handlers, Modal, verified webhooks).
- `NEXT_PUBLIC_SUPABASE_*`: public by design.
- If bypassing RLS would be required, it must be a server action.

### 7.3 RLS-first contract
- Every new table: `ENABLE ROW LEVEL SECURITY` immediately.
- No feature ships without policies.
- Default multi-tenant: every row has `org_id`; RLS checks membership via `org_memberships` + `auth.uid()`.

### 7.4 Migrations + types
- All schema changes via migrations committed to git.
- Generate and commit DB types: `lib/supabase/database.types.ts`.
- Feature `types.ts` may wrap DB types, not replace them.

### 7.5 Vertical Slice data rules
- Reads: `features/<x>/utils.ts` query helpers (pure, no mutations).
- Writes: only `features/<x>/actions.ts` (server actions).
- Prefer DB-level correctness: constraints, unique indexes, triggers, RPC for atomic multi-step ops.

### 7.6 Next.js caching with auth
- Any code path using `cookies()` / `supabase.auth.getUser()` is dynamic.
- Never statically cache per-user pages.

### 7.7 Storage defaults (CSV + compute friendly)
- Buckets private by default.
- Object paths namespaced by `auth.uid()` (and `org_id` if multi-tenant).
- Large files: upload to Storage, pass references. Never proxy bytes through Vercel.
- Compute uses short-lived signed URLs; results written to Postgres/Storage; job state is explicit.

### 7.8 Performance + simplicity
- Always `select` explicit columns (no `*`).
- Index every FK used in RLS checks (`user_id`, `org_id`, membership tables).
- Job workflows idempotent: results keyed by `job_id`, use `upsert`.
- Start with JSONB results; normalize only when queries demand it.